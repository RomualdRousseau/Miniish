global Oam {
  struct entry {
    tile[8],
    xpos[9],
    ypos[9],
    flag[8]
  }
}

module ppu (
    input clk,  // 100MHz clock
    input rst,  // reset,
    
    // VGA Signals
    
    input vga_line_clk,
    input vga_is_drawing,
    
    input scroll[16],
    
    // VRAM
    
    output vram_addr[8],
    output vram_en,
    output vram_data[4],
    
    // Sprites Memory
    
    output spr_addr[14],
    input spr_data[4],
    
    // Map Memory
    
    output map_addr[10],
    input map_data[8],
    
    // Oam Memory
    
    output oam_addr[6],
    input oam_data[32]
  ) {
  
  .clk(clk) {
    .rst(rst) {
      fsm state = {
        IDLE,
        LOOP_OAM,
        READ_OAM,
        WRITE_OAM_CACHE,
        LOOP,
        LOOP_OAM_CACHE,
        READ_OAM_CACHE,
        WRITE_OAM_PIXEL,
        READ_TILE,
        WRITE_TILE_PIXEL,
        WRITE_CHESS_PIXEL
      };
      dff count[8];
      dff haddress[8];
      dff vaddress[8];
      dff voffset[9];
      dff hoffset[9];
      dff oamcurr[7];
      dff oamidx[4];
    }
    edge_detector line_clk(#RISE(1), #FALL(0));
  }
  
  simple_dual_ram oam_cache(.rclk(clk), .wclk(clk), #SIZE(32), #DEPTH(16));
  
  sig<Oam.entry> oam_entry;
  sig vspr[9];
  sig hspr[9];
  
  always {
    
    line_clk.in = vga_line_clk;
    
    vram_addr = c{vaddress.q[0], haddress.q[0+:7]};
    vram_en = 0;
    vram_data = 4bx;
    
    map_addr = c{voffset.q[3+:5], hoffset.q[3+:5]};
    oam_addr = oamcurr.q[0+:6];
    spr_addr = 14bx;
    
    oam_cache.raddr = oamcurr.q[0+:4];
    oam_cache.waddr = oamidx.q;
    oam_cache.write_en = 0;
    oam_cache.write_data = 0;
    
    case (state.q) {
      state.IDLE:
        if (line_clk.out) {
          if (!vga_is_drawing) {
            vaddress.d = 8b0;
          }
          else {
            vaddress.d = vaddress.q + 1;
          }
          haddress.d = 8b0;
          count.d = 128;
          oamcurr.d = 0;
          oamidx.d = 0;
          state.d = state.LOOP_OAM;
        }
      
      // Scan all oam entries and select the ones on the current scan line
      
      state.LOOP_OAM:
        if (oamcurr.q == 64) {
          state.d = state.LOOP;
        }
        else {
          voffset.d = vaddress.q + scroll[0+:8];
          hoffset.d = haddress.q + scroll[8+:8];
          state.d = state.READ_OAM;
        }
      
      state.READ_OAM:
        oam_entry.tile = oam_data[0+:8];
        oam_entry.xpos = oam_data[8+:8];
        oam_entry.ypos = oam_data[16+:8];
        oam_entry.flag = oam_data[24+:8];
        if (oam_entry.tile > 0 && voffset.q  >= oam_entry.ypos && voffset.q  <= (oam_entry.ypos + 7)) {
          state.d = state.WRITE_OAM_CACHE;
        }
        else {
          oamcurr.d = oamcurr.q + 1;
          state.d = state.LOOP_OAM;
        }
      
      state.WRITE_OAM_CACHE:
        oam_cache.write_en = 1;
        oam_cache.write_data = oam_data;
        oamcurr.d = oamcurr.q + 1;
        oamidx.d = oamidx.q + 1;
        state.d = state.LOOP_OAM;
      
      // Raster pixels
      
      state.LOOP:
        if (count.q == 0) {
          state.d = state.IDLE;
        }
        else {
          count.d = count.q - 1;
          voffset.d = vaddress.q + scroll[0+:8];
          hoffset.d = haddress.q + scroll[8+:8];
          oamcurr.d = 0;
          state.d = state.LOOP_OAM_CACHE;
        }
      
      state.LOOP_OAM_CACHE:
        if (oamcurr.q[0+:4] == oamidx.q) {
          state.d = state.READ_TILE;
        }
        else {
          state.d = state.READ_OAM_CACHE;
        }
      
      state.READ_OAM_CACHE:
        oam_entry.tile = oam_cache.read_data[0+:8];
        oam_entry.xpos = oam_cache.read_data[8+:8];
        oam_entry.ypos = oam_cache.read_data[16+:8];
        oam_entry.flag = oam_cache.read_data[24+:8];
        if (oam_entry.xpos < 249 && hoffset.q[0+:8]  >= oam_entry.xpos && hoffset.q[0+:8]  <= (oam_entry.xpos + 7)) {
          vspr = voffset.q - oam_entry.ypos;
          hspr = hoffset.q - oam_entry.xpos;
          spr_addr = c{oam_entry.tile, vspr[0+:3], hspr[0+:3]};
          state.d = state.WRITE_OAM_PIXEL;
        }
        else if (oam_entry.xpos >= 249 && hoffset.q  >= oam_entry.xpos && hoffset.q  <= (oam_entry.xpos + 7)) {
          vspr = voffset.q - oam_entry.ypos;
          hspr = hoffset.q - oam_entry.xpos;
          spr_addr = c{oam_entry.tile, vspr[0+:3], hspr[0+:3]};
          state.d = state.WRITE_OAM_PIXEL;
        }
        else {
          oamcurr.d = oamcurr.q + 1;
          state.d = state.LOOP_OAM_CACHE;
        }
      
      state.WRITE_OAM_PIXEL:
        oam_entry.tile = oam_cache.read_data[0+:8];
        oam_entry.xpos = oam_cache.read_data[8+:8];
        oam_entry.ypos = oam_cache.read_data[16+:8];
        oam_entry.flag = oam_cache.read_data[24+:8];
        vspr = voffset.q - oam_entry.ypos;
        hspr = hoffset.q - oam_entry.xpos;
        spr_addr = c{oam_entry.tile, vspr[0+:3], hspr[0+:3]};
        if (spr_data == 0) {
          state.d = state.READ_TILE;
        }
        else {
          vram_en = 1;
          vram_data = spr_data;
          haddress.d = haddress.q + 1;
          state.d = state.LOOP;
        }
      
      state.READ_TILE:
        spr_addr = c{map_data, voffset.q[0+:3], hoffset.q[0+:3]};
        state.d = state.WRITE_TILE_PIXEL;
      
      state.WRITE_TILE_PIXEL:
        spr_addr = c{map_data, voffset.q[0+:3], hoffset.q[0+:3]};
        vram_en = 1;
        vram_data = spr_data;
        haddress.d = haddress.q + 1;
        state.d = state.LOOP;
      
      state.WRITE_CHESS_PIXEL:
        vram_en = 1;
        vram_data = (haddress.q[3] ^ vaddress.q[3]) * vaddress.q[3+:4];
        haddress.d = haddress.q + 1;
        state.d = state.LOOP;
    }
  }
}