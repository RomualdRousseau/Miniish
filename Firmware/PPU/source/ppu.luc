global Oam {
  struct entry {
    tile[8],
    xpos[8],
    ypos[8],
    flag[8]
  }
}

module ppu (
    input clk,  // 100MHz clock
    input rst,  // reset,
    
    // VGA Signals
    
    input vga_line_clk,
    input vga_is_drawing,
    
    // VRAM
    
    output vram_addr[8],
    output vram_en,
    output vram_data[4],
    
    // Sprites Memory
    
    output sprites_addr[14],
    input sprites_data[4],
    
    // Map Memory
    
    output map_addr[10],
    input map_data[8],
    
    // Oam Memory
    
    output oam_addr[4],
    input<Oam.entry> oam_data
  ) {
  
  sig hscroll[8];
  sig vscroll[8];
  
  .clk(clk) {
    .rst(rst) {
      fsm state = {IDLE, LOOP, LOOP_OAM, CHECK_OAM, READ_OAM, WRITE_OAM_PIXEL, READ_TILE, WRITE_TILE_PIXEL};
      dff count[8];
      dff haddress[8];
      dff vaddress[8];
      dff oam_idx[5];
    }
    edge_detector line_clk(#RISE(1), #FALL(0));
  }
  
  always {
    
    line_clk.in = vga_line_clk;
    
    vram_addr = c{vaddress.q[0], haddress.q[0+:7]};
    vram_en = 0;
    vram_data = 4bx;
    
    vscroll = vaddress.q + 0;
    hscroll = haddress.q + 0;
    
    map_addr = 10bx;
    
    sprites_addr = 14bx;
    
    oam_addr = oam_idx.q[0+:4];
    
    case (state.q) {
      state.IDLE:
        if (line_clk.out) {
          if (!vga_is_drawing) {
            vaddress.d = 8b0;
          }
          else {
            vaddress.d = vaddress.q + 1;
          }
          haddress.d = 8b0;
          count.d = 128;
          state.d = state.LOOP;
        }
      
      state.LOOP:
        if (count.q == 0) {
          state.d = state.IDLE;
        }
        else {
          count.d = count.q - 1;
          oam_idx.d = 0;
          state.d = state.LOOP_OAM;
        }
      
      state.LOOP_OAM:
        if (oam_idx.q == 16) {
          state.d = state.READ_TILE;
        }
        else {
          state.d = state.READ_OAM;
        }
      
      state.READ_OAM:
        state.d = state.CHECK_OAM;
      
      state.CHECK_OAM:
        if (oam_data.tile > 0 && vscroll >= oam_data.ypos && vscroll < (oam_data.ypos + 8) && hscroll >= oam_data.xpos && hscroll < (oam_data.xpos + 8)) {
          vscroll = vscroll - oam_data.ypos;
          hscroll = hscroll - oam_data.xpos;
          sprites_addr = c{oam_data.tile, vscroll[0+:3], hscroll[0+:3]};
          state.d = state.WRITE_OAM_PIXEL;
        }
        else {
          oam_idx.d = oam_idx.q + 1;
          state.d = state.LOOP_OAM;
        }
      
      state.WRITE_OAM_PIXEL:
        vscroll = vscroll - oam_data.ypos;
        hscroll = hscroll - oam_data.xpos;
        sprites_addr = c{oam_data.tile, vscroll[0+:3], hscroll[0+:3]};
        if (sprites_data == 0) {
          state.d = state.READ_TILE;
        }
        else {
          vram_en = 1;
          vram_data = sprites_data;
          haddress.d = haddress.q + 1;
          state.d = state.LOOP;
        }
      
      state.READ_TILE:
        map_addr = c{vscroll[3+:5], hscroll[3+:5]};
        sprites_addr = c{map_data, vscroll[0+:3], hscroll[0+:3]};
        state.d = state.WRITE_TILE_PIXEL;
      
      state.WRITE_TILE_PIXEL:
        map_addr = c{vscroll[3+:5], hscroll[3+:5]};
        sprites_addr = c{map_data, vscroll[0+:3], hscroll[0+:3]};
        // Chessboard + Cycle through all colors
        // vram_data = (haddress.q[0] ^ vaddress.q[0]) * toffset.q[0+:4];
        vram_en = 1;
        vram_data = sprites_data;
        haddress.d = haddress.q + 1;
        state.d = state.LOOP;
    }
  }
}