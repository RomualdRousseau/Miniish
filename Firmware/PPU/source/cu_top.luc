module cu_top (
    input clk,    // 100MHz clock
    input rst_n, // reset
    
    // Bus Interface
    
    input port_enb,
    input port_clk,
    
    inout port_rw,
    inout port_address[16] ,
    inout port_data[8],
    
    output port_data_rw,
    output port_dmab,
    output port_nmib,
    
    // VGA Outputs
    
    output hsync,
    output vsync,
    output hblank,
    output vblank,
    output rgb[6],
    
    output debug[2]
  ) {
  
  sig rst;
  sig dma;
  
  .clk(clk) {
    .rst(rst) {
      fsm                      this_state = {INIT, DMA_START, DMA_TRANSFER_HALF1, DMA_TRANSFER_HALF2, WAIT, WRITE_HIGH_ADDRESS, WRITE_LOW_ADDRESS, WRITE_DATA};
      dff                       this_external_address[16];
      dff                       this_internal_address[14];
      dff                       this_data_count[14];
    }
    reset_conditioner   this_reset_cond;
    pipeline                 this_delay_clk(#DEPTH(5));
    edge_detector       this_start_address_delay(#RISE(0), #FALL(1));
    edge_detector       this_start_data_delay(#RISE(1), #FALL(0));
  }
  
  .clk(clk) {
    .rst(rst) {
      pixel_clock           this_pixel_clk(#DIVIDER(4));
    }
  }
  
  .clk(this_pixel_clk.out) {
    .rst(rst) {
      vga_signals          this_vga_signals;
    }
  }
  
  .clk(this_vga_signals.pixel_clk) {
    .rst(rst) {
      vga_ramdac         this_vga_ramdac;
    }
  }
  
  .clk(clk) {
    .rst(rst) {
      ppu                      this_ppu(.vga_line_clk(this_vga_signals.line_clk));
    }
  }
  
  simple_dual_ram      this_sprites_ram (.rclk(clk), .wclk(clk), #SIZE(4), #DEPTH(128 * 128));
  simple_dual_ram      this_vram (.rclk(clk), .wclk(clk), #SIZE(4), #DEPTH(2 * 128));
  
  always {
    
    // Initialize components
    
    this_reset_cond.in = ~rst_n;
    rst = this_reset_cond.out;
    
    dma = this_state.q == this_state.DMA_START || this_state.q == this_state.DMA_TRANSFER_HALF1 || this_state.q == this_state.DMA_TRANSFER_HALF2 ? 0 : 1;
    
    this_delay_clk.in = port_clk;
    
    this_start_address_delay.in = this_delay_clk.out || port_enb;
    this_start_data_delay.in = this_delay_clk.out || port_enb;
    
    this_vram.raddr = this_vga_signals.address[6+:8];
    this_vram.waddr = this_ppu.vram_addr;
    this_vram.write_en = this_ppu.vram_en;
    this_vram.write_data = this_ppu.vram_data;
    
    this_sprites_ram.raddr = this_ppu.sprites_addr;
    this_sprites_ram.waddr = this_internal_address.q;
    this_sprites_ram.write_en = 0;
    this_sprites_ram.write_data = 0;
    
    port_rw.enable = ~dma;
    port_rw.write = 1;
    port_address.enable = 16x{ ~dma };
    port_address.write = this_external_address.q;
    port_data.enable = 0;
    port_data.write = 0;
    
    port_data_rw = !port_rw.read || !dma ? 1 : 0;
    port_dmab = dma;
    port_nmib = !this_vga_signals.vblank || !dma ? 1 : 0;
    
    this_vga_ramdac.en = !this_vga_signals.hblank && !this_vga_signals.vblank;
    this_vga_ramdac.data = this_vram.read_data;
    
    this_ppu.vga_visible = !this_vga_signals.hblank && !this_vga_signals.vblank;
    this_ppu.vga_address = this_vga_signals.address;
    this_ppu.sprites_data = this_sprites_ram.read_data;
    
    debug[0] = 0;
    debug[1] = 0;
    
    // Output VGA signals
    
    hsync = this_vga_signals.hsync;
    vsync = this_vga_signals.vsync;
    hblank = this_vga_signals.hblank;
    vblank = this_vga_signals.vblank;
    rgb = this_vga_ramdac.rgb;
    
    // Receive commands from Bus Interface
    
    case (this_state.q) {
      this_state.INIT:
        this_external_address.d = 16hA000;
        this_internal_address.d = 0;
        this_data_count.d = 64 * 128;
        this_state.d = this_state.DMA_START;
      
      this_state.DMA_START:
        if (this_data_count.q == 0) {
          this_state.d = this_state.WAIT;
        }
        else if (this_start_address_delay.out) {
          this_state.d = this_state.DMA_TRANSFER_HALF1;
        }
      
      this_state.DMA_TRANSFER_HALF1:
        if (this_start_data_delay.out) {
          this_sprites_ram.write_en = 1;
          this_sprites_ram.write_data = port_data.read[4+:4];
          this_internal_address.d = this_internal_address.q + 1;
          this_state.d = this_state.DMA_TRANSFER_HALF2;
        }
      
      this_state.DMA_TRANSFER_HALF2:
        this_vram.write_en = 1;
        this_vram.write_data = port_data.read[0+:4];
        this_external_address.d = this_external_address.q + 1;
        this_internal_address.d = this_internal_address.q + 1;
        this_data_count.d  = this_data_count.q - 1;
        this_state.d = this_state.DMA_START;
      
      this_state.WAIT:
        if (this_start_address_delay.out) {
          case (port_address.read[0+:8]) {
            8h00:
              if (!port_rw.read) {
                this_state.d = this_state.WRITE_HIGH_ADDRESS;
              }
            8h01:
              if (!port_rw.read) {
                this_state.d = this_state.WRITE_LOW_ADDRESS;
              }
            8h02:
              if (!port_rw.read) {
                this_state.d = this_state.WRITE_DATA;
              }
          }
        }
      
      this_state.WRITE_HIGH_ADDRESS:
        if (this_start_data_delay.out) {
          this_internal_address.d[7+:7] = port_data.read[0+:7];
          this_state.d = this_state.WAIT;
        }
      
      this_state.WRITE_LOW_ADDRESS:
        if (this_start_data_delay.out) {
          this_internal_address.d[0+:7] = port_data.read[0+:7];
          this_state.d = this_state.WAIT;
        }
      
      this_state.WRITE_DATA:
        if (this_start_data_delay.out) {
          this_sprites_ram.write_en = 1;
          this_sprites_ram.write_data = port_data.read[0+:4];
          this_internal_address.d = this_internal_address.q + 1;
          this_state.d = this_state.WAIT;
        }
    }
  }
}