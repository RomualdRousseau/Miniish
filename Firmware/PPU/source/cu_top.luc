module cu_top (
    input clk,                // 100MHz clock
    input rst_n,
    
    input port_enb,
    input port_rw,
    input port_clk,
    
    input port_address[16],
    input port_data[8],
    
    output port_data_rw,
    output port_dmab,
    output port_nmib,
   
    output hsync,
    output vsync,
    output hblank,
    output vblank,
    output rgb[6],
    
    output debug
  ) {
  
  const PALETTE = $reverse({
      6b000000,
      6b000001,
      6b010010,
      6b001001,
      6b100100,
      6b010101,
      6b101010,
      6b111111,
      6b110001,
      6b111000,
      6b111100,
      6b001100,
      6b001011,
      6b100110,
      6b110110,
      6b111110
    });

  sig rst;
  
  .clk(clk) {
    .rst(rst) {
      pixel_clock           this_pixel_clock(#DIVIDER(4));
      fsm                      state = {WAIT, WRITE_HIGH_ADDRESS, WRITE_LOW_ADDRESS, WRITE_DATA};
      dff                       current_address[14];
    }
    
    reset_conditioner   this_reset_cond;
    pipeline                 this_delay_clk(#DEPTH(5));
    edge_detector       this_start_address_delay(#RISE(0), #FALL(1));
    edge_detector       this_start_data_delay(#RISE(1), #FALL(0));
  }
  
  .clk(this_pixel_clock.out) {
    .rst(rst) {
      vga_signals          this_vga_signals;
    }
  }

  simple_dual_ram      this_vram (.rclk(clk), .wclk(clk), #SIZE(4), #DEPTH(128 * 128));

  always {
    
    // Initialize components
    
    this_reset_cond.in = ~rst_n;
    rst = this_reset_cond.out;
    
    this_delay_clk.in = port_clk;
    
    this_start_address_delay.in = this_delay_clk.out || port_enb;
    this_start_data_delay.in = this_delay_clk.out || port_enb;
    
    this_vram.raddr = this_vga_signals.address;
    this_vram.waddr = current_address.q;
    this_vram.write_en = 0;
    this_vram.write_data = 0;
    
    debug = 0;
    
    // Receive commands
    
    case (state.q) {
      state.WAIT:
        if (this_start_address_delay.out) {
          case (port_address[7:0]) {
              8h00:
                if (!port_rw) {
                  state.d = state.WRITE_HIGH_ADDRESS;
                }
              8h01:
                if (!port_rw) {
                  state.d = state.WRITE_LOW_ADDRESS;
                }
              8h02:
                if (!port_rw) {
                  state.d = state.WRITE_DATA;
                }
            }
        }
        
      state.WRITE_HIGH_ADDRESS:
        if (this_start_data_delay.out) {
          current_address.d[13:7] = port_data[6:0];
          state.d = state.WAIT;
        }
        
      state.WRITE_LOW_ADDRESS:
        if (this_start_data_delay.out) {
          current_address.d[6:0] = port_data[6:0];
          state.d = state.WAIT;
        }
        
      state.WRITE_DATA:
        if (this_start_data_delay.out) {
          this_vram.write_en = 1;
          this_vram.write_data = port_data[3:0];
          current_address.d = current_address.q + 1;
          state.d = state.WAIT;
        }
    }
    
    // Output control signals
  
    port_data_rw = (!port_rw & 1) | (port_rw & 0);
    port_dmab = 1;
    port_nmib = !this_vga_signals.vblank;

    // Output VGA sync signals
    
    hsync = this_vga_signals.hsync;
    vsync = this_vga_signals.vsync;
    hblank = this_vga_signals.hblank;
    vblank = this_vga_signals.vblank;
    
    // Output VGA color signals

    if (!this_vga_signals.hblank && !this_vga_signals.vblank) {
      rgb = PALETTE[(this_vga_signals.address[3] ^ this_vga_signals.address[10]) * (this_vga_signals.address[7+:7] >> 3)];
      if (this_vram.read_data > 0) {
        rgb = PALETTE[this_vram.read_data];
      }
    } else {
      rgb = 6b000000;
    }

  }
}