module cu_top (
    input clk,    // 100MHz clock
    input rst_n, // reset
    
    // Bus Interface
    
    input port_enb,
    input port_clk,
    
    inout port_rw,
    inout port_address[16] ,
    inout port_data[8],
    
    output port_data_rw,
    output port_dmab,
    output port_nmib,
    
    // VGA Outputs
    
    output hsync,
    output vsync,
    output hblank,
    output vblank,
    output rgb[6],
    
    output debug[2],
    output led[8]
  ) {
  
  sig rst;
  sig dma;
  sig i[2];
  
  .clk(clk) {
    reset_conditioner   this_reset_cond(#STAGES(10));
  }
  
  .clk(clk) {
    .rst(rst) {
      fsm                      this_state = {
        IDLE,
        // Direct access  to VRAMs
        WRITE_SPRITE_HADDR,
        WRITE_SPRITE_LADDR,
        WRITE_SPRITE_DATA,
        // DMA transfers
        DMA_SPRITE_START,
        DMA_MAP_START,
        DMA_OAM_START,
        // DMA transfer for SPRITE
        DMA_SPRITE_LOOP,
        DMA_SPRITE_TRANSFER_1,
        DMA_SPRITE_TRANSFER_2,
        // DMA transfer for MAP
        DMA_MAP_LOOP,
        DMA_MAP_TRANSFER,
        // DMA transfer for OAM
        DMA_OAM_LOOP,
        DMA_OAM_TRANSFER
      };
      fsm                      this_substate = {
        HIGH_ADDRESS,
        LOW_ADDRESS
      };
      dff                       this_external_address[16];
      dff                       this_sprites_address[14];
      dff                       this_map_address[10];
      dff                       this_oam_address[6];
      dff                       this_data_count[16];
      dff                       this_data_tmp[32];
    }
    pipeline                 this_delay_clk(#DEPTH(5));
    edge_detector       this_start_address_delay(#RISE(0), #FALL(1));
    edge_detector       this_start_data_delay(#RISE(1), #FALL(0));
  }
  
  .clk(clk) {
    .rst(rst) {
      pixel_clock           this_pixel_clk(#DIVIDER(4));
    }
  }
  
  .clk(this_pixel_clk.out) {
    .rst(rst) {
      vga_signals          this_vga_signals;
    }
  }
  
  .clk(this_vga_signals.pixel_clk) {
    .rst(rst) {
      vga_ramdac         this_vga_ramdac;
    }
  }
  
  .clk(clk) {
    .rst(rst) {
      ppu                      this_ppu(.vga_line_clk(this_vga_signals.line_clk));
    }
  }
  
  simple_dual_ram      this_sprites_ram (.rclk(clk), .wclk(clk), #SIZE(4), #DEPTH(128 * 128));
  simple_dual_ram      this_map_ram (.rclk(clk), .wclk(clk), #SIZE(8), #DEPTH(32 * 32));
  simple_dual_ram      this_oam_ram (.rclk(clk), .wclk(clk), #SIZE(32), #DEPTH(16));
  simple_dual_ram      this_vram (.rclk(clk), .wclk(clk), #SIZE(4), #DEPTH(2 * 128));
  
  always {
    
    // Initialize components
    
    this_reset_cond.in = ~rst_n;
    rst = this_reset_cond.out;
    
    dma = this_state.q >= this_state.DMA_SPRITE_LOOP ? 1 : 0;
    
    // Output Bus Interface
    
    port_rw.enable = dma;
    port_rw.write = 1;
    port_address.enable = 16x{ dma };
    port_address.write = this_external_address.q;
    port_data.enable = 0;
    port_data.write = 0;
    
    port_data_rw = !port_rw.read || dma ? 1 : 0;
    port_dmab = ~dma;
    port_nmib = !this_vga_signals.vblank || dma ? 1 : 0;
    
    // Output VGA signals
    
    hsync = this_vga_signals.hsync;
    vsync = this_vga_signals.vsync;
    hblank = this_vga_signals.hblank;
    vblank = this_vga_signals.vblank;
    rgb = this_vga_ramdac.rgb;
    
    // Setup components
    
    this_delay_clk.in = port_clk;
    
    this_start_address_delay.in = this_delay_clk.out || port_enb;
    this_start_data_delay.in = this_delay_clk.out || port_enb;
    
    this_vram.raddr = this_vga_signals.address[0+:8];
    this_vram.waddr = this_ppu.vram_addr;
    this_vram.write_en = this_ppu.vram_en;
    this_vram.write_data = this_ppu.vram_data;
    
    this_sprites_ram.raddr = this_ppu.sprites_addr;
    this_sprites_ram.waddr = this_sprites_address.q;
    this_sprites_ram.write_en = 0;
    this_sprites_ram.write_data = 0;
    
    this_map_ram.raddr = this_ppu.map_addr;
    this_map_ram.waddr = this_map_address.q;
    this_map_ram.write_en = 0;
    this_map_ram.write_data = 0;
    
    this_oam_ram.raddr = this_ppu.oam_addr;
    this_oam_ram.waddr = this_oam_address.q[2+:4];
    this_oam_ram.write_en = 0;
    this_oam_ram.write_data = 0;
    
    this_vga_ramdac.en = !this_vga_signals.hblank && !this_vga_signals.vblank;
    this_vga_ramdac.vram_data = this_vram.read_data;
    
    this_ppu.vga_is_drawing = !dma && !this_vga_signals.vblank;
    this_ppu.sprites_data = this_sprites_ram.read_data;
    this_ppu.map_data = this_map_ram.read_data;
    this_ppu.oam_data.tile = this_oam_ram.read_data[0+:8];
    this_ppu.oam_data.xpos = this_oam_ram.read_data[8+:8];
    this_ppu.oam_data.ypos = this_oam_ram.read_data[16+:8];
    this_ppu.oam_data.flag = this_oam_ram.read_data[24+:8];
    
    debug = 2b0;
    led = 8b00000001;
    
    // Receive commands from Bus Interface
    
    case (this_state.q) {
      this_state.IDLE:
        led = 8b00000011;
        if (this_start_address_delay.out) {
          case (port_address.read[0+:8]) {
            8h01:
              if (!port_rw.read) {
                if (this_substate.q == this_substate.HIGH_ADDRESS) {
                  this_state.d = this_state.WRITE_SPRITE_HADDR;
                  this_substate.d = this_substate.LOW_ADDRESS;
                }
                else {
                  this_state.d = this_state.WRITE_SPRITE_LADDR;
                  this_substate.d = this_substate.HIGH_ADDRESS;
                }
              }
            8h02:
              if (!port_rw.read) {
                this_state.d = this_state.WRITE_SPRITE_DATA;
                this_substate.d = this_substate.HIGH_ADDRESS;
              }
            8h10:
              if (!port_rw.read) {
                this_state.d = this_state.DMA_SPRITE_START;
                this_substate.d = this_substate.HIGH_ADDRESS;
              }
            8h11:
              if (!port_rw.read) {
                this_state.d = this_state.DMA_MAP_START;
                this_substate.d = this_substate.HIGH_ADDRESS;
              }
            8h12:
              if (!port_rw.read) {
                this_state.d = this_state.DMA_OAM_START;
                this_substate.d = this_substate.HIGH_ADDRESS;
              }
          }
        }
      
      this_state.WRITE_SPRITE_HADDR:
        if (this_start_data_delay.out) {
          this_sprites_address.d[7+:7] = port_data.read[0+:7];
          this_state.d = this_state.IDLE;
        }
      
      this_state.WRITE_SPRITE_LADDR:
        if (this_start_data_delay.out) {
          this_sprites_address.d[0+:7] = port_data.read[0+:7];
          this_state.d = this_state.IDLE;
        }
      
      this_state.WRITE_SPRITE_DATA:
        if (this_start_data_delay.out) {
          this_sprites_ram.write_en = 0;
          this_sprites_ram.write_data = port_data.read[0+:4];
          this_sprites_address.d = this_sprites_address.q + 1;
          this_state.d = this_state.IDLE;
        }
      
      this_state.DMA_SPRITE_START:
        if (this_start_data_delay.out) {
          this_external_address.d= c{port_data.read, 8b0};
          this_sprites_address.d = 14b0;
          this_data_count.d = 64 * 128;
          this_state.d = this_state.DMA_SPRITE_LOOP;
        }
      
      this_state.DMA_SPRITE_LOOP:
        if (this_data_count.q == 0) {
          this_state.d = this_state.IDLE;
        }
        else if (this_start_address_delay.out) {
          this_data_count.d = this_data_count.q - 1;
          this_state.d = this_state.DMA_SPRITE_TRANSFER_1;
        }
      
      this_state.DMA_SPRITE_TRANSFER_1:
        if (this_start_data_delay.out) {
          this_sprites_ram.write_en = 1;
          this_sprites_ram.write_data = port_data.read[4+:4];
          this_sprites_address.d = this_sprites_address.q + 1;
          this_state.d = this_state.DMA_SPRITE_TRANSFER_2;
        }
      
      this_state.DMA_SPRITE_TRANSFER_2:
        this_sprites_ram.write_en = 1;
        this_sprites_ram.write_data = port_data.read[0+:4];
        this_sprites_address.d = this_sprites_address.q + 1;
        this_external_address.d = this_external_address.q + 1;
        this_state.d = this_state.DMA_SPRITE_LOOP;
      
      this_state.DMA_MAP_START:
        if (this_start_data_delay.out) {
          this_external_address.d= c{port_data.read, 8b0};
          this_map_address.d = 10b0;
          this_data_count.d = 32 * 32;
          this_state.d = this_state.DMA_MAP_LOOP;
        }
      
      this_state.DMA_MAP_LOOP:
        if (this_data_count.q == 0) {
          this_state.d = this_state.IDLE;
        }
        else if (this_start_address_delay.out) {
          this_data_count.d = this_data_count.q - 1;
          this_state.d = this_state.DMA_MAP_TRANSFER;
        }
      
      this_state.DMA_MAP_TRANSFER:
        if (this_start_data_delay.out) {
          this_map_ram.write_en = 1;
          this_map_ram.write_data = port_data.read;
          this_map_address.d = this_map_address.q + 1;
          this_external_address.d = this_external_address.q + 1;
          this_state.d = this_state.DMA_MAP_LOOP;
        }
      
      this_state.DMA_OAM_START:
        if (this_start_data_delay.out) {
          this_external_address.d= c{port_data.read, 8b0};
          this_oam_address.d = 6b0;
          this_data_count.d = 4 * 16;
          this_state.d = this_state.DMA_OAM_LOOP;
        }
      
      this_state.DMA_OAM_LOOP:
        if (this_data_count.q == 0) {
          this_state.d = this_state.IDLE;
        }
        else if (this_start_address_delay.out) {
          this_data_count.d = this_data_count.q - 1;
          this_state.d = this_state.DMA_OAM_TRANSFER;
        }
      
      this_state.DMA_OAM_TRANSFER:
        if (this_start_data_delay.out) {
          i = this_oam_address.q[0+:2];
          if (i == 2b11) {
            this_oam_ram.write_en = 1;
            this_oam_ram.write_data = c{port_data.read, this_data_tmp.q[0+:24]};
          } else {
            this_data_tmp.d[(i*8)+:8] = port_data.read;
          }
          this_oam_address.d = this_oam_address.q + 1;
          this_external_address.d = this_external_address.q + 1;
          this_state.d = this_state.DMA_OAM_LOOP;
        }
    }
  }
}